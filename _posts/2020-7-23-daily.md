---
layout: post
title: "2020-07-23 日报及拓展"
subtitle: "progress group,session and deamon"
author: "Haye"
header-img: "img/post-bg-2020-07-22.jpg"
header-mask: 0.3
tags:
  - 操作系统
  - 日报
  - 会话
  - 进程
---

### 进程替换

#### 替换概述

- 用fork创建子进程后执行的是和父进程**相同的程序**,当然可以执行不同的分支(如果我们用fork创建一个子进程之后让子进程**做和父进程同样的事**，那么这个子进程没有任何意义)。
- 所以在fork之后,我们应该调用exec函数用来替换子进程的程序和数据，让子进程执行和负进程不同的程序。当进程调用exec函数组时，该进程的用户空间得到**代码和数据完全被新的程序替换**。（就是子进程的的虚拟地址空间上的数据段和代码段被替换了，然后造成映射到虚拟内存再到PCB上就也发生改变，从而对进程进行替换）。
- 调用exec并不创建新的进程。

#### 替换函数

```c++
#include<unistd.h>

int execl(const char *path, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execlp(const char *file, const char *arg, ...);
int execvp(const char *file, char *const argv[]);
```

exec函数的函数名的意义：

（1）l(list)：表示参数采用列表。 

（2）v(vector)：参数用数组。  

（3）p(path)：自动搜索环境变量PATH。 

（4）e(env)：自己维护环境变量。 

举例：

```c++
//仅提供函数样例
//同样是ls命令，execl要去自己提供完整的路径
//而execlp会自动到环境变量PATH指定的目录里去查找输入的文件名
execl("/bin/ls", "ls", "-l", NULL);
execlp("ls", "ls", "-l", NULL);
//execle自己提供环境变量
//execl这系列都是采用列表做参数，也就是const char *arg
char* const envp[] = {
	"PATH=/bin:/usr/bin",
	"TERM=console",
	NULL
};
execle("/bin/ls", "ls", "-l", NULL, envp);
//而execv则是采用传入参数数组的形式
char* const argv[] = {
		"ls",
		"-l",
		NULL
};
execv("/bin/ls", argv);
execvp("ls", argv);
//execle和execve用指定的环境变量去替代默认的环境变量
//而其他的exec函数都是采用默认的
char* const argv[] = {
		"ls",
		"-l",
		NULL
};
char* const envp[] = {
		"PATH=/bin:/usr/bin",
		"TERM=console",
		NULL
};
execve("/bin/ls", argv, envp);
```

> 没什么用的冷知识：这6个函数只有`execve`是真正的系统调用,其他5个函数都是在`execve`上包装的

返回值：成功返回0，失败时会设置errno并返回-1，然后从原程序的调用点接着往下执行。

如果一个进程想执行另一个程序，它就可以fork或vfork出一个新进程，然后调用任何一个exec函数。

> Linux的fork是**写时复制（copy-on-write）**，即fork结束后并不立刻复制父进程的内容到子进程，而是到了真正使用时才复制。为什么是这样的机制呢？因为通常fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间，而如果fork完之后我们马上就调用exec，那这些辛辛苦苦拷贝来的东西就会被立刻抹掉，这是非常不划算，所以fork就采用了写时复制的机制，这样保证了到了真正使用时才复制，这样如果下一条语句是exec，它就不会作无用功了。

> 没什么用的冷知识2：如果是vfork的话就更绝了，所有有关于内存的东西都不复制了，**父子进程的内存是完全共享的**。*但这样父子进程就共用内存栈了吧，听起来就很不安全的样子。*vfork也有个限制，子进程生成后，父进程在vfork中被内核挂起，直到子进程有了 自己的内存空间（exec**）或退出(exit)。并且，在此之前，子进程不能从调用vfork的函数中返回（同时，不能修改栈上变量、不能继续调用除exit或exec系列之外的函数，否则父进程的数据可能被改写）。
>
> 不过虽然限制很多，vfork+exec效率会比fork+exec高不少。



### 进程组、会话和终端

> 什么是终端？
>
> 查到的资料上说：
>
> **操作系统分为两个部分，一部分称作内核，另一部分成为用户交互界面**。内核部分负责系统的全部逻辑操作，由海量命令组成，这一部分是系统运行的命脉，不与用户接触；交互界面则是开机之后所有我们所看到的东西，比如窗口，软件，应用程序等等。
>
> **终端就是连接内核与交互界面的这座桥**，它允许用户在交互界面上打开一个叫做「Terminal 终端」的应用程序，在其中输入命令，系统会直接给出反馈。
>
> 其实根本上也就一句话，**能接受输入，能显示输出**。
>
> 我也分不太清终端、伪终端和虚拟终端，我一般就把类似控制台、命令行的那种都当做终端。

#### 进程组

每个进程都会属于一个**进程组**，每个进程组中可以包含多个进程。进程组会有一个**进程组长**，进程组长的PID 成为进程组的ID (PGID)，以识别进程组。默认情况下，fork产生的子进程一般和父进程是一个进程组的（一般父进程是组长）。即使进程组长先终结了，进程组依然存在，并PGID不变，直到进程组中最后一个进程终结。

我们将一些进程归为进程组的一个重要原因是我们可以将[信号](http://www.cnblogs.com/vamei/archive/2012/10/04/2711818.html)发送给一个进程组。进程组中的所有进程都会收到该信号。

可以通过setpgid和getpgid来设置和获取进程组长的pid。

>setpgrp（）是将当前进程的PID设置为该进程所属进程组的pgid，同setpgid(0)



#### 会话

多个进程组还可以构成一个**会话**。会话由进程组中**非进程组长**的进程建立，该进程称为**会话组长**，会话组长的PID称为会话的SID。

> 如果某个fork了的子进程创建了会话，那么子进程就会脱离父进程的进程组。

会话中的每个进程组称为一个**工作**。会话可以有一个进程组成为会话的前台工作，而其他的进程组是后台工作。每个会话可以连接一个**控制终端**，如果没有终端，**会话组长**可以申请打开一个。

```shell
#作业进入后台
$ ping localhost >/dev/null &
[1] 10269 # 终端显示# [1]：作业ID  10269：进程组ID
#后台切回前台
$ fg %1 # ping 进程重新切到前台
```

和进程组一样，会话组长终结了，会话依旧存在。

会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。

> 一个命令可以通过在末尾加上&方式让它在后台运行，可以通过$fg从后台工作变为前台工作。

#### 会话的创建

系统提供setsid函数来创建会话，其接口定义如下：

```c++
#include <unistd.h>
pid_t setsid(void);
```

如果调用此函数的进程不是一个进程组的组长，则此函数就会创建一个新的会话，且该进程会变成会话组长。该进程还会成为一个新进程组的组长进程，新进程组id是该进程id。

且该进程是没有控制终端的。由于会话过程对控制终端的独占性，如果该进程原来是有一个控制中断的，但是这种联系也会被打断。但是就像前面说的，**会话组长**可以重新申请打开一个。



### 守护进程

在操作系统汇总，我们会发现在系统启动的时候有很多的进程就已经开始跑了，这些进程在WINDOWS下称为服务，在linux下叫做守护进程。

守护进程是**脱离于终端并且在后台运行**的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。守护进程一般的**生命周期是系统启动到系统停止运行**，也可以通过杀死进程的方式来结束进程的生命周期。

我们也经常会利用守护进程来完成很多的系统或者自动化任务。

> 注意，守护进程虽然脱离终端，但如果你手动在终端启动守护进程，守护进程还是会在这个终端输出的，只不过你如果把终端关掉了，守护进程还会继续在跑而已。（如果是后台进程，就会随着终端的退出而停止了）

#### 创建守护进程

1. 创建子进程，父进程退出。
2. 子进程创建新会话。
3. 子进程创建孙进程，子进程退出。

> 解释一下：
>
> 先创建子进程，然后父进程退出，是为了让子进程成为孤儿进程，子进程不是进程组长（父进程才是），然后创建新会话，使子进程脱离终端和父进程的进程组。同时为了防止子进程作为会话组长重新打开终端，通过fork再次创建孙进程，然后子进程exit(0)退出，使孙进程变成孤儿，同时因为孙进程不是会话组长，所以无法重新打开终端了。

```c++
void deamon()
{
    pid_t pid=fork();
    if(pid==0)
    {
        setsid();
        pid=fork();
        if(pid==0)
        {
            umask(0);
            //这里可以写守护进程代码
        }
        else
        {
            exit(0);
        }
    }
    else
    {
        exit(0);
    }
}
int main()
{
    deamon();
    //这之后的代码也都是守护进程代码
    //...
    return 0;
}
```

> return和exit(0)的区别：
>
> 在main函数里没有区别，但是在其他自定义函数里，return 只是在return退出自定义函数（，主函数还是会执行），而exit(0)则是真正退出了。

