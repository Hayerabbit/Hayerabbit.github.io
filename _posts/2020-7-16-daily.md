---
layout: post
title: "2020-07-16 日报及拓展"
subtitle: "file operations under linux"
author: "Haye"
header-img: "img/post-bg-2020-07-16-daily.jpg"
header-mask: 0.3
tags:
  - 操作系统
  - 日报
  - linux文件系统
---



### Linux文件系统

在LINUX系统中有一个重要的概念：一切都是文件。 其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，**把一切资源都看作是文件，包括硬件设备**。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。

> Linux文件系统就是一个**树形的分层组织结构**，**根（/）作为整个文件系统的惟一起点**，其他所有目录都从该点出发。Linux的全部文件按照一定的用途归类，合理地挂载到这棵“大树”的“树枝”或“树叶”上，而这些全不用考虑文件的实际存储位置是在硬盘上，还是在CD-ROM或USB存储器中，甚至是在某一网络终端里。
>
> 为了能够按照统一的方式和方法访问文件资源，Linux提供了每种硬件设备相应的设备文件。一旦Linux系统可以访问到某种硬件，就将该硬件上的文件系统挂载到目录树中的一个子目录中。例如，用户插入USB移动存储器，Ubuntu Linux自动识别USB存储器后，将其挂载到“/media/disk”目录下，而不像Windows系统将USB存储器作为新驱动器，表示为“F：”盘。

#### 通用块设备层

不同的硬盘驱动，会提供不同的IO接口，内核认为这种杂乱的接口，不利于管理，需要把这些接口抽象一下，形成一个统一的对外接口，这样，不管你是什么硬盘，什么驱动，对外而言，它们所提供的IO接口没什么区别，都一视同仁的被看作块设备来处理。

#### 虚拟文件系统

试想，当我们创建了很多不同的文件系统，但这些文件系统都有各自的API接口，而用户想要的是，不管你是什么API，他们只关心mount/umount，或open/close等操作。

所以，VFS（虚拟文件系统）就把这些不同的文件系统做一个抽象，提供统一的API访问接口，这样，用户空间就不用关心不同文件系统中不一样的API了。VFS所提供的这些统一的API，再经过系统调用（System Call）包装一下，用户空间就可以经过SCI的系统调用来操作不同的文件系统。

Q：fopen也是打开文件的API，那么它与open有什么区别呢？

A：

①fopen是标准C库函数。所有支持C语言的操作系统，都能使用这套函数打开文件。open涉及到系统调用，返回的是**文件描述符**，fopen是C的库函数，返回的是一个**指向文件结构的指针**。

②我们知道，fopen是操作流文件，而**设备文件不可以当成流式文件来用，只能用open**，fopen是用来操纵正规文件的，并且设有**缓冲**的，一般用fopen打开普通文件，用open打开设备文件。

> 缓存文件系统(fopen)
>
> 缓冲文件系统是借助文件结构体指针来对文件进行管理（库函数），通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。缓冲文件系统的特点是：在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”， 装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。
>
> 由此可以看出，内存 “缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。

③上面也提到了fopen和open最主要的区别，fopen在用户态下就有了缓存，在进行读写操作的时候减少了用户态和内核态的切换，而open需要系统调用，每次都要在内核态和用户态切换。

> 内核态就是一种CPU的工作状态，只要有进入内核态的CPU，才能使用内核功能，比如时钟管理、中断处理、原语和对系统资源的管理。



------

### 文件标识符

首先我们知道操作系统对硬件的管理方式是先描述起来，再组织起来；同样，当我们打开文件时，操作系统在内存中要创建相应的数据结构来描述目标文件，这个数据结构就是file结构体，保存了文件相关的信息。

我们知道，进程执行open系统调用，必须让进程和文件关联起来。每个进程的PCB中都有一个指向一张表的指针，该表最重要的部分就是包含一个**指针数组**，数组里的每个元素都指向一个打开文件，所以，**文件描述符就是这个指针数组的下标**。我们只要拿到文件描述符，就能找到对应的文件。

| ...                 |
| ------------------- |
| file*(标准输入)     |
| file*(标准输出)     |
| file*(标准错误)     |
| file*(新打开的文件) |
| ...                 |

上图从第二行到最后范围都属于文件描述符数组fd[]。

现在来接触一下常用的几种系统API：

> open
>
> 打开或者创建一个文件。若成功，返回文件描述符；若出错，返回-1。
>
> path参数是要打开或创建文件的名字。flags参数可用来说明此函数的多个选项。用一个或多个常量进行“或”运算构成flags参数。
>
> 较常用的常量：
>
> O_RDONLY        只读打开。（大多数定义为0）
>
> O_WRONLY       只写打开。（大多数定义为1）
>
> O_RDWR            读、写打开。（大多数定义为2）
>
> O_EXEC              只执行打开
>
> O_CREAT            若此文件不存在则创建它。使用此选项时，open函数需同时说明第三个参数mode，用mode指定该新文件的**访问权限位**（这里的访问权限位我的理解就是linux文件的那什么246加法计算的那个）。
>
> O_EXCL               如果同时指定了O_CREAT，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作。 

> close
>
> 关闭一个已经打开文件。参数fd代表要关闭文件的文件描述符。若成功，返回0；若出错，返回-1。

> read
>
> 从打开文件中读数据，若读取成功，则返回读到的字节数，如已到达文件的尾端，则返回0。
>
> 第一个参数是文件描述符，*buf是一个指向要读取文件的文件指针。count是要读取的字节数。

> write
>
> 向打开文件写数据。若成功，返回写入的字节数；若失败，返回-1。
>
> 参数和read一样。

#### 文件描述符的分配规则

在files_struct数组当中，**找到当前没有被使用的最小的一个下标**，作为新的文件描述符。

```c++
int main()
{
    int fd = open("myfile",O_WRONLY|O_CREAT,00644);//注意这里是只写操作
    if(fd < 0){ 
        perror("open");
        return -1; 
    }   
    printf("fd: %d\n",fd);
    close(fd);
    return 0;
}
```

> 输出结果
>
> fd: 3

我们关闭0再看：

```c++
int main()
{
    close(0);
    int fd = open("myfile",O_WRONLY|O_CREAT,00644);
    if(fd < 0){ 
        perror("open");
        return -1; 
    }   
    printf("fd: %d\n",fd);
    close(fd);
    return 0;
}
```

> 输出结果
>
> fd: 0

那如果关闭1呢？

```c++
int main()
{
    close(1);
    int fd = open("myfile",O_WRONLY|O_CREAT,00644);
    if(fd < 0){ 
        perror("open");
        return -1; 
    }   
    printf("fd: %d\n",fd);
    fflush(stdout);
    close(fd);
    return 0;
}
```

此时并没有任何输出结果，但是打开程序里打开的那个myfile文件，发现本来应该输出到显示器上的内容出现在了文件里，fd = 1。也就是发生了**输出重定向**。为什么会发生重定向呢？

我们把本来的标准输出与fd下标为1的连接断掉之后根据文件描述符的分配工作，现在fd下标为1所表示内容已经变成了myfile的地址，不再是显示器文件的地址，所以输出的任何消息都会往文件中写入，进而完成输出重定向。

> 这里打开的是只写打开，如果是只读打开可能写不进去（猜测）。



------

### 系统调用

系统调用是操作系统提供给应用程序的使用接口，应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都说由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统发出服务请求，由操作系统代为完成，这样可以保证系统的稳定性与安全性，防止用户进行非法操作。

系统调用处相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在内核态下进行。

> 系统调用会让CPU从用户态→内核态。（系统调用属于中断的一种）

#### 系统调用和库函数

有的库函数会把系统调用封装成库函数，以隐藏系统调用的细节，方便应用程序进行系统调用。而系统调用属于操作系统向上层结构提供的一个作为用户和计算机硬件之间的接口。