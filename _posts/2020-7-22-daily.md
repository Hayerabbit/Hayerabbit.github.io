---
layout: post
title: "2020-07-21 日报及拓展"
subtitle: "progress in Linux"
author: "Haye"
header-img: "img/post-bg-2020-07-22.jpg"
header-mask: 0.3
tags:
  - 操作系统
  - 日报
  - 进程
---

### 进程的概念

为了更好地描述和控制程序的并发执行，引入了**进程**的概念来实现操作系统的并发性与共享性。

为了使参与并发执行的程序能独立运行，必须为之配置一个专门的数据结构——PCB（**进程控制块**）。系统利用PCB来**描述进程的基本情况和运行状态**，进而控制和管理进程。

相应地，由程序段、相关数据段和PCB组成了进程映像（进程实体）。值得注意的是，进程映像是静态的，进程是动态的。

所谓创建进程与撤销进程，实质上是创建与撤销进程的PCB。即，**PCB是进程存在的唯一标志。**

引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：进程是进程实体的运行过程，是系统进行资源分配与调度的一个独立单位。

进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。**动态性是进程最基本的特征。**

> 进程和程序的区别
>
> 进程是动态的，而程序是静态的，一个程序可以对应多个进程。



### 进程和线程的区别

线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元。线程是进程中的一个实体，是被**系统独立调度和分派的基本单位**，线程自己不拥有系统资源，但它可与同属一个进程的其他线程共享进程的所有资源。一个线程可以创建和撤销另一个线程，同一进程中多个线程之间可以并发执行。

引入线程后，**进程只作为除CPU外的系统资源分配单元，而线程则作为CPU的分配单元**。

> 同一个程序对应的两个进程它们之间资源是独立的，而一个进程里的两个线程却可以资源共享。



### 操作系统管理进程

在linux操作系统中，每个进程都有自己的进程编号pid，pid信息存储在进程的PCB里，且是操作系统唯一的.操作系统通过pid来识别进程，同时通过各种调度策略（如时间片轮转，先来先服务，短作业优先等）来控制进程的切换。

> 在Linux系统中，可以通过**ps -af**查看进程的PID和PPID；通过**ps -aux**查看进程的状态。

#### Linux下的进程状态

- 运行状态R
- 可中断睡眠S
- 不可中断睡眠D
- 暂停T
- 僵死Z
- 退出X

#### 进程切换*（非重点）

对于通常的进程而言，其创建、撤销及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的。

进程切换指的是CPU从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境发生了实质性的变化。进程切换过程如下：

（1）保存CPU上下文，包括程序计数器和其他寄存器。

（2）更新PCB信息。

（3）把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列。

（4）选择另一个进程执行，并更新其PCB。

（5）更新内存管理中的数据结构。

（6）恢复处理机上下文。



### Linux提供的进程相关API

#### getpid()&getppid()

功能描述：
getpid返回当前进程标识，getppid返回父进程标识。

头文件：

\#include <sys/types.h>	#include <unistd.h>

> 在查getpid相关资料的时候查到了Linux线程相关的有意思的东西...不过现在看不是很懂，姑且放个网址：
>
> https://blog.csdn.net/u012398613/article/details/52183708/

#### fork()

功能描述：

创建一个子进程，父子进程并发运行

子进程**复制**父进程的如下属性：

**代码段、数据段、打开文件的描述符和堆栈段**的内容，父子进程拥有相同的代码和数据。

头文件：

\#include <sys/types.h>	#include <unistd.h>

注意点：

**一次调用，两次返回**：fork执行后会分别在父进程返回一个值，子进程返回一个值；其中，父进程的返回值>0,值为子进程的`pid`，子进程的返回值=0。通过fork的返回值可以区分父进程代码和子进程代码。父进程<u>从fork返回处继续执行</u>，子进程<u>从fork返回处开始执行</u>。

**父子进程间数据独立**：因为进程是CPU分配系统资源的最小单位，所以在产生子进程时，CPU给它分配了PCB，独立的内存空间时，这基本上就是两个独立的进程了，从fork之后，它们的数据并不会互通。

*我觉得复制就是对fork的最好解释。在fork的时候，把原进程此时的数据段和代码段统统拷贝一份，然后拷贝的那一份+系统给它分配的内存+PCB就组成了一个新的进程，我是这样理解的*。

还有一点有点难描述，所以这里我借用代码的例子来具体讲解。

```c++
int main(int argc,char *argv[])
{
    int number=10;
    pid_t pid_id;
    number++;
    pid_id=fork();
    if(pid_id==0)//子进程可跑的代码段
    {
        //...
    }
    else if(pid_id>0)//父进程可跑
    {
        //...
        number++;
    }
    cout<<number<<endl;
}
```

得到的结果：

> 11
>
> 12

结果输出了两次，说明**cout<<number<<endl**被执行了两次，也就是fork之后，只要不是在**else if(pid_id>0)**内的代码块，子进程一样可以跑的，所以假设我把**pid_id=fork()**和**number++**调换一下位置，得到的也是一样的结果。但是在**else if(pid_id>0)**里的number++由于是只有父进程可以跑，而子进程和父进程之间数据独立，所以最后得到的父进程的number和子进程的就不一样了。

>题外话，fork其实有个问题，我查到的资料上说，**fork只会复制当前线程到子进程**，但是fork之后,**除了文件锁以外,其他的锁都会被继承。**额这就有一个问题，从操作系统的角度上看，对于每一个锁都有它的持有者，即对它进行lock操作的线程。假设在fork之前，一个线程对某个锁进行的lock操作，即持有了该锁，然后另外一个线程调用了fork创建子进程。可是在子进程中持有那个锁的线程却"消失"了，从子进程的角度来看，这个锁被“永久”的上锁了，因为它的持有者“蒸发”了。这就产生了死锁。
>
>这个问题之后应该会有解决的办法就是了。不过这里先记一下，免得以后掉坑里。



### 僵尸进程和孤儿进程

*~~学归学，你咋还骂人呢？~~*

我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程（因为并发）,即父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

> **孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。**
>
> **僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

关于这一点的具体操作验证，指路俺滴bro的blog：[https://wukurua.github.io/2020/07/21/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/](https://wukurua.github.io/2020/07/21/多进程编程/)

~~*没法，vs通过ssh操作太麻烦惹*~~

#### 问题以及危害

在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号,退出状态,运行时间等)。直到父进程通过wait / waitpid来取时才释放。（可以自己用ps-au命令查看一下)但这样就导致了问题，**如果进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

**孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。**

**任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

> 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿就能瞑目而去啦。



#### 运用fork预防僵尸问题

有一个很骚的操作来预防僵尸进程的产生，就是当你想fork产生子进程时，fork两次。（换 爹）

你只要第一个子进程足够短，然后它去世的话它fork产生的子子进程就会变成孤儿，由init进程接管，就不怕变成僵尸了。

*~~不过我觉得这个应该用处不大，就图个乐。~~*



#### wait()&waitpid()

功能描述：

进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。　

头文件：

\#include <sys/types.h> 	#include <sys/wait.h>

函数原型：

pid_t wait(int *status)

pid_t waitpid(pid_t pid,int *status,int options)

参数：

**wait**

参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样：

pid = wait(NULL);

**waitpid**

pid:从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。 　　　　

- pid>0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束,waitpid就会一直等下去。
- pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。 　　
- pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
- pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。 　

options: options提供了一些额外的选项来控制waitpid，目前在Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用。如果使用了WNOHANG参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。

返回值：

如果成功，wait会返回被收集的子进程的进程ID

如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。



> 简单来说：①wait()&waitpid()可以用来为子进程“收尸”。②wait()&waitpid()可以实现进程同步，即阻塞等待到子进程结束。



#### wait()&waipid()返回状态检测

|       宏定义        |                     描述                      |
| :-----------------: | :-------------------------------------------: |
|  WIFEXITED(status)  |      如果子进程正常结束，返回一个非零值       |
| WEXITSTATUS(status) | 如果WIFEXITED非零，返回子进程退出码（返回值） |
| WIFSIGNALED(status) |     子进程因未捕获信号而终止，返回非零值      |
|  WTERMSIG(status)   |    如果WIFSIGNALED返回非零值，返回信号代码    |
| WIFSTOPPED(status)  |        如果子进程终止，返回一个非零值         |
|  WSTOPSIG(status)   |    如果WIFSTOPPED返回非零值，返回信号代码     |

代码例子：

```c++
int main(int argc,char *argv[])
{
    pid_t pid;
    pid=fork();
    int process_state=0;
    if(pid==0)//child process
    {
        cout<<"child pid:"<<getpid()<<endl;
        for(int i=0;i<5;i++)
        {
            cout<<"child process run."<<endl;
            sleep(1);
        }
        return 233;
    }
    else if(pid>0)//father process
    {
        pid=fork();
        if(pid==0)//child process
        {
            cout<<"child2 pid:"<<getpid()<<endl;
            for(int i=0;i<5;i++)
            {
                cout<<"child2 process run."<<endl;
                sleep(1);
            }
            return 77;
        }
        pid=waitpid(pid,&process_state,0);

        if(WIFEXITED(process_state))//complete normally
        {
            cout<<"child exec code:"<<WEXITSTATUS(process_state)<<endl;
        }
        cout<<"father pid:"<<getpid()<<endl;
        cout<<"wait child pid:"<<pid<<endl;
        for(int i=0;i<3;i++)
        {
            cout<<"child process run."<<endl;
            sleep(2);
        }
    }
    //execute this if not distinguish the return value of fork
    cout<<"Common exec: pid:"<<getpid()<<endl;
    return 0;
}
```

得到结果：

>child pid:50877
>child process run.
>Detaching from process 50878
>child2 pid:50878
>child2 process run.
>child process run.
>child2 process run.
>child process run.
>child2 process run.
>child process run.
>child2 process run.
>child process run.
>child2 process run.
>child exec code:77
>father pid:50868
>wait child pid:50878
>child process run.
>child process run.
>child process run.
>Common exec: pid:50868